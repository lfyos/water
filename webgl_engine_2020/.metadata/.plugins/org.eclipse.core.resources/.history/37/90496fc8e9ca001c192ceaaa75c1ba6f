package driver_distance_tag;

import kernel_engine.client_information;
import kernel_engine.engine_kernel;
import kernel_transformation.point;
import kernel_transformation.plane;
import kernel_common_class.const_value;
import kernel_common_class.jason_string;
import kernel_component.component;
import kernel_file_manager.file_reader;
import kernel_file_manager.file_writer;

public class distance_tag_array
{
	public distance_tag_item distance_tag_array[];
	private String directory_component_name,distance_tag_file_name;
	private int display_precision;
	private double min_view_distance;
	private boolean has_done_load_flag;

	public distance_tag_array(
			String my_directory_component_name,String my_distance_tag_file_name,
			int my_display_precision,double my_min_view_distance)
	{
		distance_tag_array=new distance_tag_item[] {};
		directory_component_name=my_directory_component_name;
		distance_tag_file_name=file_reader.separator(my_distance_tag_file_name);
		display_precision=my_display_precision;
		min_view_distance=my_min_view_distance;
		has_done_load_flag=false;
	}
	public void destroy()
	{
		distance_tag_array=null;
	}
	public void save(engine_kernel ek)
	{
		distance_tag_item p;
		component directory_comp,comp_p0,comp_px;
		if((directory_comp=ek.component_cont.search_component(directory_component_name))==null)
			return;
		String my_distance_tag_file_name=directory_comp.component_directory_name+distance_tag_file_name;
		file_writer fw=new file_writer(my_distance_tag_file_name,directory_comp.component_charset);
		for(int i=0,ni=distance_tag_array.length;i<ni;i++) {
			if((p=distance_tag_array[i]).state!=2)
				continue;
			if((comp_p0=ek.component_cont.get_component(p.p0_component_id))==null)
				continue;
			if((comp_px=ek.component_cont.get_component(p.px_component_id))==null)
				continue;
			fw.println("/*	p0_component	*/	",comp_p0.component_name);
			fw.println("/*	px_component	*/	",comp_px.component_name);
			fw.println("/*	function_id		*/	",p.function_id);
			fw.print  ("/*	p0				*/	",p.p0.x).print("	",p.p0.y).println("	",p.p0.z);
			fw.print  ("/*	px				*/	",p.px.x).print("	",p.px.y).println("	",p.px.z);
			fw.print  ("/*	py				*/	",p.py.x).print("	",p.py.y).println("	",p.py.z);
			fw.println();
		}
		fw.close();
	}
	public void jason(engine_kernel ek,client_information ci)
	{
		distance_tag_item p;
		component comp_p0,comp_px;
		ci.request_response.print  ("[");
		String follow_str="";
		for(int i=0,ni=distance_tag_array.length;i<ni;i++) {
			if((p=distance_tag_array[i]).state!=2)
				continue;
			if((comp_p0=ek.component_cont.get_component(p.p0_component_id))==null)
				continue;
			if((comp_px=ek.component_cont.get_component(p.px_component_id))==null)
				continue;
			ci.request_response.println(follow_str);follow_str=",";
			
			ci.request_response.println("	{");
			ci.request_response.print  ("	\"p0_component\":	",	jason_string.change_string(comp_p0.component_name)).println(",");
			ci.request_response.print  ("	\"px_component\":	",	jason_string.change_string(comp_px.component_name)).println(",");
			ci.request_response.print  ("	\"function_id\":	",	p.function_id).println(",");
			ci.request_response.print  ("	\"p0\":[		",		p.p0.x).print(",",p.p0.y).print(",",p.p0.z).println(",1.0],");
			ci.request_response.print  ("	\"px\":[		",		p.px.x).print(",",p.px.y).print(",",p.px.z).println(",1.0],");
			ci.request_response.print  ("	\"py\":[		",		p.py.x).print(",",p.py.y).print(",",p.py.z).println(",1.0],");
			ci.request_response.println("	\"tag_string\":		",	p.tag_str);
			ci.request_response.print  ("	}");
		}
		ci.request_response.println();
		ci.request_response.println("]");
	}
	public void load(boolean init_flag,engine_kernel ek,client_information ci)
	{
		if(init_flag)
			if(has_done_load_flag)
				return;
		has_done_load_flag=true;
		
		component directory_comp,comp_p0,comp_px;
		if((directory_comp=ek.component_cont.search_component(directory_component_name))==null)
			return;
		distance_tag_array=new distance_tag_item[] {};
		String my_distance_tag_file_name=directory_comp.component_directory_name+distance_tag_file_name;
		for(file_reader fr=new file_reader(my_distance_tag_file_name,directory_comp.component_charset);;) {
			String component_name_p0=fr.get_string();
			String component_name_px=fr.get_string();
			
			if(fr.eof()) {
				fr.close();
				return;
			}
			comp_p0=ek.component_cont.search_component(component_name_p0);
			comp_px=ek.component_cont.search_component(component_name_px);
			
			int function_id=fr.get_int();
			double p0_x=fr.get_double(),p0_y=fr.get_double(),p0_z=fr.get_double();
			double px_x=fr.get_double(),px_y=fr.get_double(),px_z=fr.get_double();
			double py_x=fr.get_double(),py_y=fr.get_double(),py_z=fr.get_double();
			
			if((comp_p0==null)||(comp_px==null))
				continue;
			
			point global_p0=comp_p0.absolute_location.multiply(p0_x,p0_y,p0_z);
			point global_px=comp_px.absolute_location.multiply(px_x,px_y,px_z);
			point global_py=comp_p0.absolute_location.multiply(py_x,py_y,py_z);
			point dx=global_px.sub(global_p0),dy=global_py.sub(global_p0),dz=dx.cross(dy);
			dy=dz.cross(dx).expand(dy.distance());
			point py=comp_p0.absolute_location.negative().multiply(global_p0.add(dy));

			distance_tag_item bak[]=distance_tag_array;
			distance_tag_array=new distance_tag_item[bak.length+1];
			for(int i=0,ni=bak.length;i<ni;i++)
				distance_tag_array[i]=bak[i];
			distance_tag_array[bak.length]=new distance_tag_item(
				comp_p0.component_id,comp_px.component_id,function_id,
				p0_x,p0_y,p0_z,		px_x,px_y,px_z,		py.x,py.y,py.z);
			distance_tag_array[bak.length].set_tag_str(display_precision,ek,ci);
		}
	}
	public boolean clear_all_distance_tag(engine_kernel ek,client_information ci)
	{
		distance_tag_array=new distance_tag_item[] {};
		save(ek);
		return false;
	}
	public boolean clear_distance_tag(engine_kernel ek,client_information ci)
	{
		String str;
		if((str=ci.request_response.get_parameter("id"))==null)
			return true;
		int tag_index=Integer.parseInt(str);
		if((tag_index<0)||(tag_index>=distance_tag_array.length))
			return true;
		distance_tag_item bak[]=distance_tag_array;
		distance_tag_array=new distance_tag_item[bak.length-1];
		for(int i=0,j=0,ni=bak.length;i<ni;i++)
			if(tag_index!=i)
				distance_tag_array[j++]=bak[i];
		save(ek);
		return false;
	}
	public boolean modify_distance_tag(engine_kernel ek,client_information ci)
	{
		for(int i=0,ni=distance_tag_array.length;i<ni;i++)
			switch(distance_tag_array[i].state) {
			default:
			case 0:
			case 1:
				return true;
			case 2:
				break;
			}
		String str;
		if((str=ci.request_response.get_parameter("id"))==null)
			return true;
		int tag_index=Integer.parseInt(str);
		if((tag_index<0)||(tag_index>=distance_tag_array.length))
			return true;
		distance_tag_array[tag_index].state=1;
		return false;
	}
	public boolean switch_distance_tag(engine_kernel ek,client_information ci)
	{
		String str;
		if((str=ci.request_response.get_parameter("id"))==null)
			return true;
		int tag_index=Integer.parseInt(str);
		if((tag_index<0)||(tag_index>=distance_tag_array.length))
			return true;
		distance_tag_array[tag_index].set_function(ci);
		return false;
	}
	public boolean touch_distance_tag(engine_kernel ek,client_information ci)
	{
		distance_tag_item p;
		component distance_comp;
		point touch_point,global_p0,global_px,global_py,view_p0,view_px,view_py,top_point,down_point;
		
		for(int i=0,ni=distance_tag_array.length;i<ni;i++) {
			switch((p=distance_tag_array[i]).state) {
			case 0:	//input second point
				if(ci.parameter.comp==null)
					return true;
				if((touch_point=ci.selection_camera_result.caculate_local_focus_point(ci.parameter))==null)
					return true;
				distance_comp=ek.component_cont.get_component(p.p0_component_id);
				global_p0=distance_comp.absolute_location.multiply(p.p0);
				global_px=ci.parameter.comp.absolute_location.multiply(touch_point);
				if(global_px.sub(global_p0).distance2()<const_value.min_value2)
					return true;
				if(new plane(global_p0,global_px).error_flag)
					return true;
				view_p0=ci.display_camera_result.matrix.multiply(global_p0);
				view_px=ci.display_camera_result.matrix.multiply(global_px);
				view_p0.z=view_px.z;
				if(view_px.sub(view_p0).distance2()<(min_view_distance*min_view_distance))
					return true;
				
				global_py=ci.selection_camera_result.to_me_direct.cross(global_px.sub(global_p0));
				if(global_py.distance2()<=const_value.min_value2)
					return true;
				
				top_point=ci.display_camera_result.negative_matrix.multiply(view_px.x, 1,view_px.z);
				down_point=ci.display_camera_result.negative_matrix.multiply(view_px.x,-1,view_px.z);
				global_py=global_py.expand(top_point.sub(down_point).distance()/100).add(global_p0);
				
				p.px_component_id=ci.parameter.comp.component_id;
				p.px=touch_point;
				p.py=distance_comp.absolute_location.negative().multiply(global_py);
				p.set_tag_str(display_precision,ek,ci);
				
				return false;
			case 1://confirm third point
				distance_comp=ek.component_cont.get_component(p.px_component_id);
				global_px=distance_comp.absolute_location.multiply(p.px);
				view_px=ci.display_camera_result.matrix.multiply(global_px);
				
				distance_comp=ek.component_cont.get_component(p.p0_component_id);
				global_p0=distance_comp.absolute_location.multiply(p.p0);
				view_p0=ci.display_camera_result.matrix.multiply(global_p0);

				plane p_pl;
				
				double up_dot_value=ci.selection_camera_result.up_direct.dot(global_px.sub(global_p0));
				double right_dot_value=ci.selection_camera_result.right_direct.dot(global_px.sub(global_p0));
				if(Math.abs(up_dot_value)<Math.abs(right_dot_value))
					p_pl=new plane(global_p0,global_px,global_px.add(ci.selection_camera_result.up_direct));
				else
					p_pl=new plane(global_p0,global_px,global_px.add(ci.selection_camera_result.right_direct));
				if(p_pl.error_flag)
					return true;
				
				global_py=p_pl.insection_point(
						ci.selection_camera_result.negative_matrix.multiply(new point(0,0,ci.parameter.depth+0)),
						ci.selection_camera_result.negative_matrix.multiply(new point(0,0,ci.parameter.depth+1)));
				if(global_py==null)
					return true;
				if((global_py=(new plane(global_p0,global_px)).project_to_plane_location().multiply(global_py))==null)
					return true;
				
				if(global_py.sub(global_p0).distance2()<const_value.min_value2)
					return true;
				if(new plane(global_p0,global_py).error_flag)
					return true;
				
				view_p0=ci.display_camera_result.matrix.multiply(global_p0);
				view_py=ci.display_camera_result.matrix.multiply(global_py);
				view_p0.z=view_py.z;
				if(view_py.sub(view_p0).distance2()<(min_view_distance*min_view_distance))
					return true;

				p.py=distance_comp.absolute_location.negative().multiply(global_py);
				return false;
			default:
				break;
			}
		}
		return true;
	}
	public boolean mark_distance_tag(engine_kernel ek,client_information ci)
	{
		distance_tag_item p;
		component distance_comp;
		point mark_point,global_p0,global_px,global_py,view_p0,view_px,view_py;

		for(int i=0,ni=distance_tag_array.length;i<ni;i++) {
			switch((p=distance_tag_array[i]).state){
			case 0:	//input second point
				if(ci.parameter.comp==null)
					return true;
				if((mark_point=ci.selection_camera_result.caculate_local_focus_point(ci.parameter))==null)
					return true;
				p.px_component_id=ci.parameter.comp.component_id;
				p.px=mark_point;
				
				distance_comp=ek.component_cont.get_component(p.p0_component_id);
				global_p0=distance_comp.absolute_location.multiply(p.p0);
				global_px=ci.parameter.comp.absolute_location.multiply(p.px);
				if(global_px.sub(global_p0).distance2()<const_value.min_value2)
					return true;
				if(new plane(global_p0,global_px).error_flag)
					return true;
				
				view_p0=ci.display_camera_result.matrix.multiply(global_p0);
				view_px=ci.display_camera_result.matrix.multiply(global_px);
				view_p0.z=view_px.z;
				if(view_px.sub(view_p0).distance2()<(min_view_distance*min_view_distance))
					return true;
				
				p.state=1;
				p.set_tag_str(display_precision,ek,ci);
				return false;
			case 1://confirm third point
				distance_comp=ek.component_cont.get_component(p.p0_component_id);
				global_p0=distance_comp.absolute_location.multiply(p.p0);
				global_py=distance_comp.absolute_location.multiply(p.py);
				
				if(global_py.sub(global_p0).distance2()<const_value.min_value2)
					return true;
				if(new plane(global_p0,global_py).error_flag)
					return true;
				view_p0=ci.display_camera_result.matrix.multiply(global_p0);
				view_py=ci.display_camera_result.matrix.multiply(global_py);
				view_p0.z=view_py.z;
				if(view_py.sub(view_p0).distance2()<(min_view_distance*min_view_distance))
					return true;
				p.state=2;
				save(ek);
				return false;
			default:
				break;
			}
		}
		//input first point
		if(ci.parameter.comp==null)
			return true;
		if((mark_point=ci.selection_camera_result.caculate_local_focus_point(ci.parameter))!=null){
			distance_tag_item bak[]=distance_tag_array;
			distance_tag_array=new distance_tag_item[bak.length+1];
			for(int i=0,ni=bak.length;i<ni;i++)
				distance_tag_array[i]=bak[i];
			
			p=new distance_tag_item(mark_point,ci.parameter.comp.component_id);
			distance_tag_array[distance_tag_array.length-1]=p;
		}
		return false;
	}
	public boolean test_location_modify(engine_kernel ek,client_information ci)
	{
		boolean ret_val=false;
		distance_tag_item p;
		for(int i=0,ni=distance_tag_array.length;i<ni;i++)
			switch((p=distance_tag_array[i]).state) {
			default:
				break;
			case 1:
			case 2:
				long new_location_version_p0=ek.component_cont.get_component(
						p.p0_component_id).get_absolute_location_version();
				long new_location_version_px=ek.component_cont.get_component(
						p.px_component_id).get_absolute_location_version();
				if(p.location_version_p0>=new_location_version_p0)
					if(p.location_version_px>=new_location_version_px)
						break;
				p.location_version_p0=new_location_version_p0;
				p.location_version_px=new_location_version_px;

				ret_val=true;
				component distance_comp;
				distance_comp=ek.component_cont.get_component(p.px_component_id);
				point global_px=distance_comp.absolute_location.multiply(p.px);
				distance_comp=ek.component_cont.get_component(p.p0_component_id);
				point global_py=distance_comp.absolute_location.multiply(p.py);
				point global_p0=distance_comp.absolute_location.multiply(p.p0);
				double dy_distance=global_py.sub(global_p0).distance();
				
				plane p_pl;
				double up_dot_value=ci.selection_camera_result.up_direct.dot(global_px.sub(global_p0));
				double right_dot_value=ci.selection_camera_result.right_direct.dot(global_px.sub(global_p0));
				if(Math.abs(up_dot_value)<Math.abs(right_dot_value))
					p_pl=new plane(global_p0,global_px,global_px.add(ci.selection_camera_result.up_direct));
				else
					p_pl=new plane(global_p0,global_px,global_px.add(ci.selection_camera_result.right_direct));
				global_py=p_pl.project_to_plane_location().multiply(global_py);
				global_py=new plane(global_p0,global_px).project_to_plane_location().multiply(global_py);
				global_py=global_py.sub(global_p0).expand(dy_distance).add(global_p0);
				
				p.py=distance_comp.absolute_location.negative().multiply(global_py);
				p.set_tag_str(display_precision,ek,ci);
				
				break;
			}
		return ret_val;
	}
}
