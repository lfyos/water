package driver_lession_18_dynamic_environment_mapping_texture;

import kernel_camera.camera_result;
import kernel_component.component;
import kernel_component.component_collector;
import kernel_driver.instance_driver;
import kernel_engine.client_information;
import kernel_engine.engine_kernel;
import kernel_render.render_target;
import kernel_render.target_viewport;
import kernel_transformation.box;
import kernel_transformation.point;
import kernel_transformation.location;

public class extended_instance_driver extends instance_driver
{
	private double model_scale;
	private int target_id[],camera_id[];
	public void destroy()
	{
		super.destroy();
		target_id=null;
		camera_id=null;
	}
	public extended_instance_driver(component my_comp,int my_driver_id,
			double my_model_scale,int my_camera_id[])
	{
		super(my_comp,my_driver_id);
		
		model_scale=my_model_scale;
		camera_id=my_camera_id;
		target_id=new int[camera_id.length];
		for(int i=0,ni=target_id.length;i<ni;i++)
			target_id[i]=-1;
	}
	public void response_init_instance_data(engine_kernel ek,client_information ci)
	{
		box my_box=comp.get_component_box(true);
		double my_box_radius=my_box.distance();
		point global_center_point=my_box.center();
		for(int i=0,ni=camera_id.length;i<ni;i++) {
			component eye_comp=ek.camera_cont.camera_array[camera_id[i]].eye_component;
			point local_center_point=eye_comp.caculate_negative_absolute_location().multiply(global_center_point);
			point p=local_center_point.sub(new point(0,0,my_box_radius));
			location loca=eye_comp.move_location.multiply(location.move_rotate(p.x,p.y,p.z,0,0,0));
			eye_comp.modify_location(loca,ek.component_cont);
			double half_fovy_tanl=Math.tan(Math.PI/4.0);
			ek.camera_cont.camera_array[camera_id[i]].parameter.half_fovy_tanl=half_fovy_tanl;
			ek.camera_cont.camera_array[camera_id[i]].parameter.bak_half_fovy_tanl=half_fovy_tanl;
			ek.camera_cont.camera_array[camera_id[i]].parameter.distance=my_box_radius;
		}
	}
	public boolean check(int render_buffer_id,int parameter_channel_id,int data_buffer_id,
			engine_kernel ek,client_information ci,camera_result cr,component_collector collector)
	{
		if(!(cr.target.main_display_target_flag))
			return true;
		int bak_target_id[]=target_id;
		target_id=new int[bak_target_id.length];
		for(int i=0,ni=target_id.length;i<ni;i++){
			render_target rt=new render_target(
				comp.component_name+"/"+Integer.toString(i),camera_id[i],
				ci.display_camera_result.target.parameter_channel_id,
				new component[]{ek.component_cont.root_component},null,null,512,512,10,null,
				new target_viewport[]
				{
					new target_viewport(-1,-1,2,2,0,0,new double[]{0.0,0.0,0.0,1.0})
//					new target_viewport(-1,-1,2,2,3,0,new double[]{0.0,0.0,0.0,1.0}),
//					new target_viewport(-1,-1,2,2,4,0,new double[]{0.0,0.0,0.0,1.0}),
//					new target_viewport(-1,-1,2,2,5,0,new double[]{0.0,0.0,0.0,1.0}),
				});
			ci.target_container.register_target(rt,-1,null);
			target_id[i]=rt.target_id;
		}
		for(int i=0,ni=target_id.length;i<ni;i++)
			if(target_id[i]!=bak_target_id[i]){
				update_component_parameter_version(0);
				break;
			}
		return false;
	}
	public void create_render_parameter(
			int render_buffer_id,int parameter_channel_id,int data_buffer_id,
			engine_kernel ek,client_information ci,camera_result cr)
	{
		ci.request_response.print(data_buffer_id);
	}
	public void create_component_parameter(engine_kernel ek,client_information ci)
	{
		ci.request_response.print("[",comp.component_id);
		for(int i=0;i<6;i++)
			ci.request_response.print(",",target_id[i]);
		ci.request_response.print(",",model_scale);
		ci.request_response.print("]");
	}
	public String[] response_event(int parameter_channel_id,engine_kernel ek,client_information ci)
	{
		return null;
	}
}
