package driver_distance_tag;

import kernel_engine.client_information;
import kernel_engine.engine_kernel;
import kernel_transformation.point;
import kernel_transformation.plane;
import kernel_common_class.const_value;
import kernel_component.component;

public class distance_tag_array
{
	public distance_tag_item distance_tag_array[];
	private int display_precision,operate_component_id;
	
	public distance_tag_array(int my_display_precision)
	{
		distance_tag_array=new distance_tag_item[] {};
		display_precision=my_display_precision;
		operate_component_id=-1;
	}
	public void destroy()
	{
		distance_tag_array=null;
	}
	public boolean delete_distance_tag(engine_kernel ek,client_information ci)
	{
		String str;
		if((str=ci.request_response.get_parameter("id"))==null)
			return true;
		int tag_index=Integer.parseInt(str);
		if((tag_index<0)||(tag_index>=distance_tag_array.length))
			return true;
		distance_tag_item bak[]=distance_tag_array;
		distance_tag_array=new distance_tag_item[bak.length-1];
		for(int i=0,j=0,ni=bak.length;i<ni;i++)
			if(tag_index!=i)
				distance_tag_array[j++]=bak[i];
		return false;
	}
	public boolean modify_distance_tag(engine_kernel ek,client_information ci)
	{
		for(int i=0,ni=distance_tag_array.length;i<ni;i++)
			switch(distance_tag_array[i].state) {
			default:
			case 0:
			case 1:
				return true;
			case 2:
				break;
			}
		String str;
		if((str=ci.request_response.get_parameter("id"))==null)
			return true;
		int tag_index=Integer.parseInt(str);
		if((tag_index<0)||(tag_index>=distance_tag_array.length))
			return true;
		distance_tag_array[tag_index].state=1;
		return false;
	}
	public boolean switch_distance_tag(engine_kernel ek,client_information ci)
	{
		String str;
		if((str=ci.request_response.get_parameter("id"))==null)
			return true;
		int tag_index=Integer.parseInt(str);
		if((tag_index<0)||(tag_index>=distance_tag_array.length))
			return true;
		distance_tag_array[tag_index].state=1;
		return false;
	}
	public boolean touch_distance_tag(engine_kernel ek,client_information ci)
	{
		distance_tag_item p;
		
		for(int i=0,ni=distance_tag_array.length;i<ni;i++) {
			switch((p=distance_tag_array[i]).state) {
			case 0:	//input second point
			{
				point my_point=ci.selection_camera_result.caculate_local_focus_point(ci.parameter);
				if(my_point==null)
					return true;
				my_point=ci.parameter.comp.absolute_location.multiply(my_point);
				if(my_point.sub(p.p0).distance2()<const_value.min_value2)
					return true;
				p.px=my_point;
				
				my_point=ci.display_camera_result.matrix.multiply(my_point);
				my_point=ci.display_camera_result.negative_matrix.multiply(my_point.x, 1,my_point.z).sub(
						 ci.display_camera_result.negative_matrix.multiply(my_point.x,-1,my_point.z));
				p.py=ci.selection_camera_result.to_me_direct.cross(p.px.sub(p.p0));
				if(p.py.distance2()>const_value.min_value2)
					p.py=p.py.expand(my_point.distance()/1000);
				p.py=p.py.add(p.p0);
				
				p.set_tag_str(operate_component_id,display_precision,ek,ci);
				return false;
			}
			case 1://confirm third point
			{	
				plane p0_pl,p_pl;
				if((p0_pl=new plane(p.p0,p.px)).error_flag)
					return true;
				double up_dot_value=ci.selection_camera_result.up_direct.dot(p.px.sub(p.p0));
				double right_dot_value=ci.selection_camera_result.right_direct.dot(p.px.sub(p.p0));
				if(Math.abs(up_dot_value)<Math.abs(right_dot_value))
					p_pl=new plane(p.p0,p.px,p.px.add(ci.selection_camera_result.up_direct));
				else
					p_pl=new plane(p.p0,p.px,p.px.add(ci.selection_camera_result.right_direct));
				if(p_pl.error_flag)
					return true;
				
				point my_point=p_pl.insection_point(
						ci.selection_camera_result.negative_matrix.multiply(new point(0,0,ci.parameter.depth+0)),
						ci.selection_camera_result.negative_matrix.multiply(new point(0,0,ci.parameter.depth+1)));
				if(my_point==null)
					return true;
				if((my_point=p0_pl.project_to_plane_location().multiply(my_point))==null)
					return true;
				p.py=my_point;
				p.set_tag_str(operate_component_id,display_precision,ek,ci);
				return false;
			}
			default:
				break;
			}
		}
		return true;
	}
	public boolean mark_distance_tag(engine_kernel ek,client_information ci)
	{
		point my_point;
		component comp;
		distance_tag_item p;

		operate_component_id=((comp=ek.component_cont.search_component())==null)?-1:comp.component_id;
		
		for(int i=0,ni=distance_tag_array.length;i<ni;i++) {
			switch((p=distance_tag_array[i]).state) {
			case 0:	//input second point
				if((my_point=ci.selection_camera_result.caculate_local_focus_point(ci.parameter))==null)
					return true;
				p.px=ci.parameter.comp.absolute_location.multiply(my_point);
				p.py=p.p0;
				if(p.px.sub(p.p0).distance2()<const_value.min_value2)
					return true;
				if(new plane(p.p0,p.px).error_flag)
					return true;
				p.state=1;
				p.set_tag_str(operate_component_id,display_precision,ek,ci);
				return false;
			case 1://confirm third point
				p.state=2;
				p.set_tag_str(operate_component_id,display_precision,ek,ci);
				return false;
			default:
				break;
			}
		}
		//input first point
		if((my_point=ci.selection_camera_result.caculate_local_focus_point(ci.parameter))!=null){
			distance_tag_item bak[]=distance_tag_array;
			distance_tag_array=new distance_tag_item[bak.length+1];
			for(int i=0,ni=bak.length;i<ni;i++)
				distance_tag_array[i]=bak[i];
			p=new distance_tag_item(ci.parameter.comp.absolute_location.multiply(my_point));
			p.set_tag_str(operate_component_id,display_precision,ek,ci);
			distance_tag_array[distance_tag_array.length-1]=p;
		}
		return false;
	}
}
