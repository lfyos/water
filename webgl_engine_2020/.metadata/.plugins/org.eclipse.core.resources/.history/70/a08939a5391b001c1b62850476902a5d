[
	["vertex_location","vertex_normal","vertex_material","vertex_id","vertex_texture"],
	["vertex_location","vertex_normal","vertex_material","vertex_id","vertex_texture"],
	["vertex_location","vertex_normal","vertex_material","vertex_id","vertex_texture"],
	["vertex_location","vertex_normal","vertex_material","vertex_id","vertex_texture"],
	
	["vertex_location","vertex_normal","vertex_material","vertex_id","vertex_texture"],
	["vertex_location","vertex_normal","vertex_material","vertex_id","vertex_texture"],
	["vertex_location","vertex_normal","vertex_material","vertex_id","vertex_texture"],
	["vertex_location","vertex_normal","vertex_material","vertex_id","vertex_texture"],
	
	["vertex_location","vertex_normal","vertex_material","vertex_id","vertex_texture"],
	["vertex_location","vertex_normal","vertex_material","vertex_id","vertex_texture"],
	["vertex_location","vertex_normal","vertex_material","vertex_id","vertex_texture"],
	["vertex_location","vertex_normal","vertex_material","vertex_id","vertex_texture"]
		
],

function (	method_id,			pass_id,				parameter_channel_id,	render_id,			part_id,
			render_buffer_id,	component_data_array,	project_matrix,			do_render_number,	render)
{
	var gl								=render.gl;
	var shader_program					=render.render_program.render_program[render_id].shader_program;
	var part_buffer_object				=render.buffer_object.buffer_object[render_id][part_id];
	
	var component_location				=render.component_location_data;
	
	var data_buffer						=render.data_buffer[render_id][part_id];
	var pickup							=render.pickup;

	var permanent_render_id				=render.permanent_render_part_id[render_id][part_id].permanent_render_id;
	var permanent_part_id				=render.permanent_render_part_id[render_id][part_id].permanent_part_id;
	
	var part_information				=render.part_information[render_id][part_id].information;
	var part_material					=render.part_information[render_id][part_id].material;
	var part_property					=render.part_information[render_id][part_id].property;
	var part_component_id_and_driver_id	=render.part_information[render_id][part_id].part_component_id_and_driver_id;
	var instance_initialize_data		=render.part_information[render_id][part_id].instance_initialize_data;
	var part_initialize_data			=render.part_information[render_id][part_id].part_initialize_data;
	
	var clip_plane						=render.clip_plane_array[render_buffer_id];
	var clip_plane_matrix				=render.clip_plane_matrix_array[render_buffer_id];
	
	var camera_object_parameter			=render.camera.camera_object_parameter;
	var camera_render_parameter			=render.camera.camera_render_parameter[render_buffer_id];
	var camera_id						=camera_render_parameter.camera_id;
	var camera_component_id				=camera_object_parameter[camera_id].component_id;
	
	var utility							=render.utility;
	var computer						=render.computer;
	var current_time					=render.current_time;
	var modifier_current_time			=render.modifier_current_time;
	
	function create_vertex_array(p)
	{
		p.vertex_array_object_flag=true;
		p.vertex_array_object=new Array();
		
		for(var i=0;;i++){
			p.vertex_array_object[i]=gl.createVertexArray();
			gl.bindVertexArray(p.vertex_array_object[i]);
			gl.bindBuffer(gl.ARRAY_BUFFER,p.buffer_object);
		
			var offset=0,attribute_id;
			var attribute_name=["vertex_location","vertex_normal","vertex_material","vertex_id","vertex_texture"];
			for(var j=0,nj=attribute_name.length;j<nj;j++){
				attribute_id=gl.getAttribLocation (shader_program,attribute_name[j]);
				if(p.item_size<=offset)
					gl.disableVertexAttribArray	(attribute_id);
				else{
					gl.vertexAttribPointer		(attribute_id,4,gl.FLOAT,false,p.item_size*4,offset*4);
					gl.enableVertexAttribArray	(attribute_id);
					offset+=4;
				}
			}

			attribute_id=gl.getAttribLocation (shader_program,"vertex_unit");
			if(p.item_size<=offset)
				gl.disableVertexAttribArray	(attribute_id);
			else{
				gl.vertexAttribPointer		(attribute_id,1,gl.FLOAT,false,p.item_size*4,offset*4);
				gl.enableVertexAttribArray	(attribute_id);
				offset++;
			}
			
			attribute_id=gl.getAttribLocation (shader_program,"vertex_value");
			if(i==0){
				gl.disableVertexAttribArray	(attribute_id);
			}else{
				offset+=i-1;
				if(p.item_size<=offset)
					gl.disableVertexAttribArray	(attribute_id);
				else{
					gl.vertexAttribPointer		(attribute_id,1,gl.FLOAT,false,p.item_size*4,offset*4);
					gl.enableVertexAttribArray	(attribute_id);
					offset++;
				}
			}
			if(p.item_size<=offset)
				return;
		}
	}
	
	function draw_primitive(primitive_type,
		part_buffer_object,display_value_id,material,my_do_clip_close,draw_flag)
	{
		gl.uniform1i(shader_program.draw_flag_uniform,draw_flag);
		for(var i=0,ni=part_buffer_object.region_data.length;i<ni;i++){
			var p=part_buffer_object.region_data[i];
			var my_material=material[p.material_id%material.length];
			if(my_material.do_clip_close|my_do_clip_close){
				if(typeof(p.opengl_flag)=="undefined"){
					p.opengl_flag=true;
					gl.deleteVertexArray(p.vertex_array_object);
					create_vertex_array(p);
				}
				gl.bindTexture(gl.TEXTURE_2D,my_material.texture_object);
				gl.bindBufferBase(gl.UNIFORM_BUFFER,0,my_material.uniform_block_buffer_object);
				gl.bindVertexArray(p.vertex_array_object[display_value_id%(p.vertex_array_object.length)]);
				gl.drawArrays(primitive_type,0,p.item_number);
			}
		}
	}
	
	function do_render(display_code,part_buffer_object,primitive_type)
	{		
		var material;
		
		if((material=part_material[0].material).length<=0)
			return;
		
		for(var i=0,ni=component_data_array.length;i<ni;i++){
			var buffer_id					=component_data_array[i][0];
			var my_display_code				=component_data_array[i][1];
			var my_display_flag				=component_data_array[i][2];

			while(data_buffer[buffer_id].length>1)
				data_buffer[buffer_id].shift();
			
			var my_close_clip_plane_number	= data_buffer[buffer_id][0][0];
			var display_value_id			= data_buffer[buffer_id][0][1];
			var effective_selected_flag		=(data_buffer[buffer_id][0][2]>0)?2:0;
			
			if(primitive_type!=gl.TRIANGLES)
				display_value_id=0;
			
			var component_id=part_component_id_and_driver_id[buffer_id][0];
			var discard_flag=1;
			
			if((my_display_code&display_code)==0){
				if(render.pickup.component_id!=component_id)
					continue;
				if(my_display_flag<1)		//don't do other render for pickup component.
					continue;				//except for main display and selection display.
				if((display_code&4)!=0)		//don't display depth for pickup component,display it directly.
					continue;				//otherwise rendered depth will hide normal color display. 
				discard_flag=0;
			}
			
			component_location.get_component_location(component_id);
			
			var clip_flag=0,do_close_flag=false;
			if(my_close_clip_plane_number>0){
				clip_flag=4;
				if(primitive_type==gl.TRIANGLES){
					gl.enable(gl.STENCIL_TEST); 
					gl.stencilFunc(gl.ALWAYS,0x01,0x01);
		 			gl.stencilOp(gl.KEEP,gl.INVERT,gl.INVERT);
		 			do_close_flag=true;
	 			}
			}
			
			draw_primitive(primitive_type,part_buffer_object,display_value_id,material,true,
					discard_flag+effective_selected_flag+clip_flag+(display_value_id>0?16:0));

			if(do_close_flag){
				gl.stencilFunc(gl.NOTEQUAL,0x00,0x01);
				gl.stencilOp(gl.KEEP,gl.ZERO,gl.ZERO);
				
				clip_flag=8;
				draw_primitive(primitive_type,part_buffer_object,display_value_id,material,false,
					discard_flag+effective_selected_flag+clip_flag+(display_value_id>0?16:0));

				gl.disable(gl.STENCIL_TEST);
			}
		}
	}

	if(do_render_number.engine_render==0){
		shader_program.sampler=gl.createSampler();
		gl.samplerParameteri(shader_program.sampler,gl.TEXTURE_MAG_FILTER,	gl.LINEAR);
		gl.samplerParameteri(shader_program.sampler,gl.TEXTURE_MIN_FILTER,	gl.LINEAR);
		gl.samplerParameteri(shader_program.sampler,gl.TEXTURE_WRAP_S,		gl.MIRRORED_REPEAT);
		gl.samplerParameteri(shader_program.sampler,gl.TEXTURE_WRAP_T,		gl.MIRRORED_REPEAT);
		
		shader_program.default_texture_object=utility.load_texture_image();
		gl.uniform1i(gl.getUniformLocation(shader_program,"texture_sampler"),0);

		gl.uniformBlockBinding(shader_program,gl.getUniformBlockIndex(shader_program,"material_information"),0);
		gl.uniformBlockBinding(shader_program,gl.getUniformBlockIndex(shader_program,"light_information"),	 1);
		gl.uniformBlockBinding(shader_program,gl.getUniformBlockIndex(shader_program,"light_position"),	 	 2);
		
		shader_program.draw_flag_uniform	=gl.getUniformLocation(shader_program,"draw_flag");
		
		gl.uniform1i(shader_program.draw_flag_uniform,	1);
	};
	
	var max_light_number=8;
	
	if(do_render_number.engine_part==0){
		var light=part_material[0].light,light_data=new Array();
		for(var i=0,ni=light.length;(i<ni)&&(i<max_light_number);i++)
			light_data=light_data.concat(light[i].parameter);
		while(light_data.length<(max_light_number*16))
			light_data.push(-1,0,0,1,	0,0,0,1,	0,0,0,1,	0,0,0,1);
		light_data=light_data.concat(part_material[0].global_ambient);
		
		var my_light_uniform_block_buffer_object=gl.createBuffer();
		gl.bindBuffer(gl.UNIFORM_BUFFER,my_light_uniform_block_buffer_object);
		gl.bufferData(gl.UNIFORM_BUFFER,new Float32Array(light_data),gl.STATIC_DRAW);
		part_material[0].light_parameter_uniform_block_buffer_object=my_light_uniform_block_buffer_object;
		
		light_data=new Array();
		for(var i=0;i<max_light_number;i++)
			light_data.push(0,0,0,1);
		my_light_uniform_block_buffer_object=gl.createBuffer();
		gl.bindBuffer(gl.UNIFORM_BUFFER,my_light_uniform_block_buffer_object);
		gl.bufferData(gl.UNIFORM_BUFFER,new Float32Array(light_data),gl.DYNAMIC_DRAW);
		part_material[0].light_position_uniform_block_buffer_object=my_light_uniform_block_buffer_object;

		var material=part_material[0].material;
		for(var i=0,ni=material.length;i<ni;i++){
			if(material[i].texture_file==null)
				material[i].texture_object=shader_program.default_texture_object;
			else
				material[i].texture_object=utility.load_server_part_image(
						render_id,part_id,[["file",material[i].texture_file]]);
			material[i].uniform_block_buffer_object=gl.createBuffer();
			gl.bindBuffer(gl.UNIFORM_BUFFER,material[i].uniform_block_buffer_object);
			gl.bufferData(gl.UNIFORM_BUFFER,new Float32Array(material[i].parameter),gl.STATIC_DRAW);
		}
	}
	
	if(do_render_number.render_part==0){
		var light=part_material[0].light,light_data=new Array();
		for(var i=0,ni=light.length;i<ni;i++){
			var light_component_id	=camera_object_parameter[light[i].camera_id].component_id;
			var light_distance		=camera_object_parameter[light[i].camera_id].distance;
			var light_matrix		=component_location.get_component_location_routine(light_component_id);
			var light_position		=computer.caculate_coordinate(light_matrix,0,0,light_distance);
			light_data.push(light_position[0],light_position[1],light_position[2],light_position[3]);
		}
		gl.bindBuffer(gl.UNIFORM_BUFFER,part_material[0].light_position_uniform_block_buffer_object);
		gl.bufferSubData(gl.UNIFORM_BUFFER,0,new Float32Array(light_data),0);
	}

	gl.bindBufferBase(gl.UNIFORM_BUFFER,1,part_material[0].light_parameter_uniform_block_buffer_object);
	gl.bindBufferBase(gl.UNIFORM_BUFFER,2,part_material[0].light_position_uniform_block_buffer_object);
	
	gl.disable(gl.STENCIL_TEST);
	
	gl.activeTexture(gl.TEXTURE0);
	gl.bindSampler(0,shader_program.sampler);
	
	switch(method_id){
	case 0://render scene before depth rendering
		break;
	case 1://render scene for component selection
		do_render(2+8+16+32,part_buffer_object.point,	gl.POINTS);
		do_render(2+8+16+32,part_buffer_object.face,	gl.TRIANGLES);
		break;
	case 2://render scene for shadow depth
		if(part_material[0].transparency_flag)
			break;
		do_render(2+8+16,	part_buffer_object.face,	gl.TRIANGLES);
		break;
	case 3://render depth only,no color rendering
		if(part_material[0].transparency_flag)
			break;
		gl.colorMask(false,false,false,false);
		do_render(4,		part_buffer_object.face,	gl.TRIANGLES);
		gl.colorMask(true,true,true,true);
		break;
	case 4://render scene after depth rendering
		
		gl.polygonOffset(1,1);
		gl.enable(gl.POLYGON_OFFSET_FILL);
		do_render(8,		part_buffer_object.frame,	gl.LINES);
		do_render(16,		part_buffer_object.edge,	gl.LINES);
		do_render(32,		part_buffer_object.point,	gl.POINTS);
		gl.disable(gl.POLYGON_OFFSET_FILL);
			
		if(!(part_material[0].transparency_flag))
			do_render(2,	part_buffer_object.face,	gl.TRIANGLES);
		
		break;
	case 5://render scene for blending
		if(!(part_material[0].transparency_flag))
			break;
		gl.blendFunc(gl.SRC_ALPHA,gl.ONE_MINUS_SRC_ALPHA);
		gl.enable(gl.BLEND);
		gl.depthMask(false);
		do_render(2,		part_buffer_object.face,	gl.TRIANGLES);	
		gl.disable(gl.BLEND);
		gl.depthMask(true);

		break;
	}
}
