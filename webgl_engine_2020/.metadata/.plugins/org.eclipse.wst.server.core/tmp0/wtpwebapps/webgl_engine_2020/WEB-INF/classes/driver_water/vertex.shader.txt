
in		vec4	aVertexPosition;

out		vec3	place;
out		float	flag;

uniform		vec4	par,ex_par,boundary;

vec3 caculate_point(float x,float y,float z)
{
	vec4 p0,right_direction,up_direction;
	
	p0=target_info.negative_projection_matrix*vec4(-1.0,-1.0,z,1.0);
	p0=vec4(p0.xyz/p0.w,1.0);
	
	right_direction=target_info.negative_projection_matrix*vec4(1.0,-1.0,z,1.0);
	right_direction=vec4((right_direction.xyz/right_direction.w)-(p0.xyz),1.0);
	
	up_direction=target_info.negative_projection_matrix*vec4(-1.0,1.0,z,1.0);
	up_direction=vec4((up_direction.xyz/up_direction.w)-(p0.xyz),1.0);
		
	return (p0+x*right_direction+y*up_direction).xyz;
}
void caculate_location()
{
	float 	x=-0.1+1.2*aVertexPosition.x/aVertexPosition.w;
	float 	y=-0.1+1.2*aVertexPosition.y/aVertexPosition.w;

	vec3 p0=caculate_point(x,y,-1.0),p1=caculate_point(x,y,1.0);
	vec3 d=p1-p0;
	float t=(par.y-p0.y)/d.y;	
	place=p0+t*d;
	flag=(t<0.0)?1.0:0.0;
}
void modify_location()
{
	float p=(target_info.far_value_ratio+1.0)*(target_info.distance);
	float alf=par.x,amplitude=ex_par.x,wavelength=ex_par.y,attenuation=ex_par.z;

	place.y =amplitude*sin(alf+(place.x+place.z)/wavelength);
	place.y =place.y*pow(attenuation,-dot(place.xz,place.xz)/(p*p));
	place.y+=par.y;
}
void main(void)
{
	caculate_location();
	if((boundary.x==boundary.y)||(boundary.z==boundary.w))
		modify_location();
	else if((place.x>=boundary.x)&&(place.x<=boundary.y)&&(place.z>=boundary.z)&&(place.z<=boundary.w))
		modify_location();
	else
		place.y=par.y;
	gl_Position=target_info.projection_matrix*vec4(place,1.0);
}
