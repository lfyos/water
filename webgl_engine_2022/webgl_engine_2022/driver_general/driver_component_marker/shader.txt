struct marker_information 
{
	marker_component_id		:	i32,
	marker_driver_id		:	i32,
	marker_body_id			:	i32,
	marker_system_id		:	i32,

	face_normal_color		:	vec4<f32>,
	face_pickup_color		:	vec4<f32>,
				
	edge_normal_color		:	vec4<f32>,
	edge_pickup_color		:	vec4<f32>,			
				
	point_normal_color		:	vec4<f32>,
	point_pickup_color		:	vec4<f32>,
	
	marker_position			:	vec4<f32>,
	
	marker_face_x_scale		:	f32,
	marker_face_y_scale		:	f32,
	marker_edge_y_scale		:	f32,
	tmp_0					:	f32
};

@group(1) @binding(0) var <uniform> marker_info	:	marker_information;
@group(1) @binding(1) var marker_texture		:	texture_2d<f32>;
@group(1) @binding(2) var marker_sampler		:	sampler;

override primitive_type		:	i32;

struct vertex_to_fragment_struct
{
	@builtin(position)	vertex_position		:	vec4<f32>,
	@location(1)		vertex_texture		:	vec4<f32>
};
struct fragment_to_target_struct
{
	@location(0) 			color	:	vec4<f32>,
	@location(1) 			id		:	vec4<i32>,
	@builtin(frag_depth)	depth	:	f32
};

@vertex
fn vertex_main(
		@location(0) my_coord		:	vec4<f32>,
		@location(1) my_texture		:	vec4<f32>
	)->vertex_to_fragment_struct
{
	var vf:vertex_to_fragment_struct;
	
	vf.vertex_texture=vec4(my_texture.x,1.0-my_texture.y,my_texture.zw);
	
	vf.vertex_position=location_info.matrix*marker_info.marker_position;
	vf.vertex_position=target_info.projection_matrix*vf.vertex_position;
	vf.vertex_position=vf.vertex_position/vf.vertex_position.w;
	
	var face_width	=marker_info.marker_face_x_scale/f32(target_info.target_width);
	var face_height	=marker_info.marker_face_y_scale/f32(target_info.target_height);
	var edge_height	=marker_info.marker_edge_y_scale;
	if(vf.vertex_position.y+edge_height+face_height>1.0){
		edge_height=1.0-vf.vertex_position.y-face_height;
		if(edge_height<0.0){
			edge_height=0.0;
			if(vf.vertex_position.y+face_height>1.0){
				face_height=1.0-vf.vertex_position.y;
				if(face_height<0.0){
					face_height=0.0;
				}
			}
		}
	}
	switch(primitive_type){
	default:	//face
	{
		vf.vertex_position.x=vf.vertex_position.x+my_coord.x*face_width;
		vf.vertex_position.y=vf.vertex_position.y+edge_height+my_coord.y*face_height;
		break;
	}
	case 1:		//edge
	{
		vf.vertex_position.y=vf.vertex_position.y+my_coord.y*edge_height;
		break;
	}
	case 2:		//point
	{
		break;
	}
	}
	return vf;
}

@fragment
fn fragment_main(vf	:	vertex_to_fragment_struct) -> fragment_to_target_struct
{
	var ft 	:	fragment_to_target_struct;
	
	ft.depth=0.0;
	ft.id=vec4(marker_info.marker_system_id,marker_info.marker_body_id,0,0);
	
	switch(primitive_type){
	default:	//face
	{
		ft.depth=0.0;
		
		ft.color=textureSample(marker_texture,marker_sampler,vf.vertex_texture.xy);
		if(dot(ft.color.rgb,ft.color.rgb)<0.75){
			ft.color.a=0.0;
		}else{
			ft.color.a=1.0;
		}
		ft.color=vec4(marker_info.face_normal_color.rgb,ft.color.a);
		if(   (system_info.pickup_component_id==marker_info.marker_component_id)
			&&(system_info.pickup_driver_id==marker_info.marker_driver_id)
			&&(system_info.pickup_body_id==marker_info.marker_body_id))
		{
			ft.color=vec4(marker_info.face_pickup_color.rgb,ft.color.a);
		}
		break;
	}
	case 1:	//edge
	{
		ft.depth=vf.vertex_position.z;
		ft.color=vec4(marker_info.edge_normal_color.rgb,1.0);
		if(   (system_info.pickup_component_id==marker_info.marker_component_id)
			&&(system_info.pickup_driver_id==marker_info.marker_driver_id)
			&&(system_info.pickup_body_id==marker_info.marker_body_id))
		{
			ft.color=vec4(marker_info.edge_pickup_color.rgb,1.0);
		}
		break;
	}
	case 2:
	{
		ft.depth=vf.vertex_position.z;
		ft.color=vec4(marker_info.point_normal_color.rgb,1.0);
		if(   (system_info.pickup_component_id==marker_info.marker_component_id)
			&&(system_info.pickup_driver_id==marker_info.marker_driver_id)
			&&(system_info.pickup_body_id==marker_info.marker_body_id))
		{
			ft.color=vec4(marker_info.point_pickup_color.rgb,1.0);
		}
		break;
	}
	}
	return ft;
}
