const line_depth_bias	=0.0000025;
const point_depth_bias	=0.0000050;

override primitive_type	: i32;
override point_size		: f32;

struct vertex_to_fragment_struct
{
	@builtin(position)	vertex_position		:	vec4<f32>,
		
	@location(0)		vertex_id_0			:	vec4<f32>,
	@location(1)		vertex_id_1			:	vec4<f32>,
	@location(2)		vertex_value		:	vec4<f32>,
	
	@location(3)		vertex_material		:	vec4<f32>,
	@location(4)		vertex_texture		:	vec4<f32>
};

struct fragment_id_target_struct
{
	@location(0) 	id_0			:	vec4<i32>,
	@location(1) 	id_1			:	vec4<i32>,
	
	@builtin(frag_depth)	depth	:		f32	
};
struct fragment_color_target_struct
{
	@location(0) 	color			:	vec4<f32>,
	@builtin(frag_depth)	depth	:		f32	
};

@vertex
fn vertex_main(
		@location(0) my_coord		:	vec4<f32>,
		@location(1) my_normal		:	vec4<f32>,
		@location(2) my_material	:	vec4<f32>,
		@location(3) my_id			:	vec4<f32>,
		@location(4) my_texture		:	vec4<f32>,
		
		@builtin(vertex_index)	my_vertex_index	:	u32
		
	)->vertex_to_fragment_struct
{
	var vf:vertex_to_fragment_struct;
	
	vf.vertex_position	=target_info.projection_matrix*(id_info.matrix*my_coord);
	vf.vertex_position	=vf.vertex_position/vf.vertex_position.w;
	
	vf.vertex_id_0		=vec4<f32>(f32(id_info.component_system_id),my_id.x,my_id.y,0.0);
	vf.vertex_id_1		=vec4<f32>(my_texture.x,my_texture.y,my_id.z,my_id.w);
	vf.vertex_value		=vec4<f32>(5.5,6.6,7.7,vf.vertex_position.z);
	
	vf.vertex_material	=vec4(my_material.rgb,1.0);
	vf.vertex_texture	=my_texture;
	
	switch(primitive_type){
	default:
		{
			break;
		}
	case 1,3:	//point id  pickup
		{
			vf.vertex_texture=point_texture_position[my_vertex_index%6];
			
			vf.vertex_position=target_info.negative_screen_move_matrix*vf.vertex_position;
			vf.vertex_position=system_info.main_target_screen_move_matrix*vf.vertex_position;
			
			vf.vertex_position=vf.vertex_position/vf.vertex_position.w+vf.vertex_texture*
				vec4(	point_size/f32(system_info.main_target_view_width),
						point_size/f32(system_info.main_target_view_height),
						0.0,0.0);
			vf.vertex_position=system_info.main_target_negative_screen_move_matrix*vf.vertex_position;
			vf.vertex_position=target_info.screen_move_matrix*vf.vertex_position;	
			break;
		}
	case 7,8:	//point id  rendering
		{
			vf.vertex_texture=point_texture_position[my_vertex_index%6];
			vf.vertex_position=vf.vertex_position+vf.vertex_texture*
				vec4(	point_size/f32(target_info.target_view_width),
						point_size/f32(target_info.target_view_height),
						0.0,0.0);
			break;
		}
	}
	
	return vf;
}

@fragment
fn fragment_id_face(vf:vertex_to_fragment_struct) -> fragment_id_target_struct
{
	var ret_val	:	fragment_id_target_struct;
	
	ret_val.depth=vf.vertex_value.w;
	ret_val.id_0 =vec4(i32(vf.vertex_id_0.x),i32(vf.vertex_id_0.y),	i32(vf.vertex_id_0.z),0);
	ret_val.id_1 =vec4(			-1,					 -1,			i32(vf.vertex_id_1.z),i32(vf.vertex_id_1.w));

	return ret_val;
}

@fragment
fn fragment_value_face(vf:vertex_to_fragment_struct) ->fragment_color_target_struct
{
	var ret_val	:	fragment_color_target_struct;
	
	ret_val.depth=vf.vertex_value.w;
	ret_val.color=vf.vertex_value;
	
	return ret_val;
}

@fragment
fn fragment_id_point(vf:vertex_to_fragment_struct) -> fragment_id_target_struct
{
	var ret_val	:	fragment_id_target_struct;
	
	ret_val.depth=vf.vertex_value.w-2.0*point_depth_bias;
	ret_val.id_0 =vec4(i32(vf.vertex_id_0.x),i32(vf.vertex_id_0.y),i32(vf.vertex_id_0.z),2);
	ret_val.id_1 =vec4(i32(vf.vertex_id_1.x),i32(vf.vertex_id_1.y),i32(vf.vertex_id_1.z),i32(vf.vertex_id_1.w));
	
	if(dot(vf.vertex_texture,vf.vertex_texture)>1.0)
	{
		discard;
	}
	if(system_info.pickup_component_id	!=id_info.component_id)	{return ret_val;}
  	if(system_info.pickup_driver_id		!=id_info.driver_id)	{return ret_val;}
	if(system_info.pickup_body_id		!=i32(vf.vertex_id_0.y)){return ret_val;}
	if(system_info.pickup_face_id		!=i32(vf.vertex_id_0.z)){return ret_val;}
	
	ret_val.depth=0.0;
	
	return ret_val;
}

@fragment
fn fragment_value_point(vf:vertex_to_fragment_struct) ->fragment_color_target_struct
{
	var ret_val	:	fragment_color_target_struct;
	
	ret_val.depth=vf.vertex_value.w-2.0*point_depth_bias;
	ret_val.color=vf.vertex_value;

	if(dot(vf.vertex_texture,vf.vertex_texture)>1.0)
	{
		discard;
	}
	if(system_info.pickup_component_id	!=id_info.component_id)	{return ret_val;}
  	if(system_info.pickup_driver_id		!=id_info.driver_id)	{return ret_val;}
	if(system_info.pickup_body_id		!=i32(vf.vertex_id_0.y)){return ret_val;}
	if(system_info.pickup_face_id		!=i32(vf.vertex_id_0.z)){return ret_val;}
	
	ret_val.depth=0.0;
	
	return ret_val;
}

@fragment
fn fragment_color_face(vf:vertex_to_fragment_struct) ->fragment_color_target_struct
{
	var ret_val	:	fragment_color_target_struct;
	
	ret_val.color=vf.vertex_material;
	ret_val.depth=vf.vertex_value.w;
	
	return ret_val;
}

@fragment
fn fragment_color_edge(vf:vertex_to_fragment_struct) ->fragment_color_target_struct
{
	var ret_val	:	fragment_color_target_struct;
	
	ret_val.depth=vf.vertex_value.w-line_depth_bias;
	ret_val.color=vec4<f32>(0.0,0.0,0.0,1.0);
	
	return ret_val;
}

@fragment
fn fragment_color_frame(vf:vertex_to_fragment_struct) ->fragment_color_target_struct
{
	var ret_val	:	fragment_color_target_struct;
	
	ret_val.depth=vf.vertex_value.w-line_depth_bias;
	ret_val.color=vec4<f32>(0.25,0.25,0.25,1.0);
	
	return ret_val;
}

@fragment
fn fragment_color_pickup_point(vf:vertex_to_fragment_struct) ->fragment_color_target_struct
{
	var ret_val	:	fragment_color_target_struct;
	
	ret_val.depth=vf.vertex_value.w-2.0*point_depth_bias;
	ret_val.color=vec4<f32>(0.0,0.0,0.0,1.0);

	loop {
  		if(system_info.pickup_component_id	!=id_info.component_id)	{break;}
  		if(system_info.pickup_driver_id		!=id_info.driver_id)	{break;}
		if(system_info.pickup_body_id		!=i32(vf.vertex_id_0.y)){break;}
		if(system_info.pickup_face_id		!=i32(vf.vertex_id_0.z)){break;}
		if(dot(vf.vertex_texture,vf.vertex_texture)>1.0)			{break;}
		
		var my_loop_id		=i32(vf.vertex_id_1.x);
		var my_edge_id		=i32(vf.vertex_id_1.y);
		var my_primitive_id	=i32(vf.vertex_id_1.z);
		var my_vertex_id	=i32(vf.vertex_id_1.w);
		
		ret_val.depth=2.0*point_depth_bias;
		ret_val.color=vec4<f32>(0.0,0.0,1.0,1.0);
		if(system_info.pickup_loop_id		!=my_loop_id)		{return ret_val;}
		if(system_info.pickup_edge_id		!=my_edge_id)		{return ret_val;}
		
		ret_val.depth=1.0*point_depth_bias;
		ret_val.color=vec4<f32>(0.0,1.0,0.0,1.0);
		if(system_info.pickup_primitive_id	!=my_primitive_id)	{return ret_val;}
		if(system_info.pickup_vertex_id		!=my_vertex_id)		{return ret_val;}
		
		ret_val.depth=0.0*point_depth_bias;
		ret_val.color=vec4<f32>(1.0,0.0,0.0,1.0);
		return ret_val;
	}
	discard;
	return ret_val;
}

@fragment
fn fragment_color_normal_point(vf:vertex_to_fragment_struct) ->fragment_color_target_struct
{
	var ret_val	:	fragment_color_target_struct;
	
	ret_val.color=vec4<f32>(0.0,1.0,0.0,1.0);
	ret_val.depth=vf.vertex_value.w-2.0*point_depth_bias;
	return ret_val;
}