
override normal_color	: vec4<f32>;
override focus_color	: vec4<f32>;

struct vertex_to_fragment_struct
{
	@builtin(position)	vertex_position		:	vec4<f32>,	
	@location(0)		vertex_id			:	vec4<f32>,
	@location(1)		vertex_value		:	vec4<f32>
};
struct fragment_to_target_struct
{
	@location(0) 	color	:	vec4<f32>,
	@location(1) 	id		:	vec4<i32>
};

@vertex
fn vertex_main(
		@location(0) my_coord		:	vec4<f32>,
		@location(1) my_id			:	vec4<f32>,
		@location(2) my_scale		:	vec4<f32>
	)->vertex_to_fragment_struct
{
	var vf:vertex_to_fragment_struct;

	vf.vertex_position=location_info.matrix*vec4<f32>(0.0,0.0,0,1.0);
	vf.vertex_position=vec4<f32>(my_coord.xyz*my_scale.x+vf.vertex_position.xyz/vf.vertex_position.w,1.0);
	
	if(target_info.projection_type_flag>0){
		vf.vertex_position=target_info.other_projection_matrix*vf.vertex_position;
	}else{
		vf.vertex_position=target_info.		 projection_matrix*vf.vertex_position;
	}
	
	vf.vertex_id		=my_id;
	vf.vertex_value		=vec4<f32>(0.0,0.0,0.0,vf.vertex_position.z/vf.vertex_position.w);
	return vf;
}

@fragment
fn fragment_main(vf	:	vertex_to_fragment_struct) -> fragment_to_target_struct
{
	var ft : fragment_to_target_struct;
	
	ft.id=vec4<i32>(
			id_info.component_system_id,
			i32(vf.vertex_id.x),
			i32(vf.vertex_id.y),
			i32(vf.vertex_id.z));
	
	ft.color=vf.vertex_value;
	if(method_info.method_id!=0){
		ft.color=normal_color;
		if(id_info.component_id==system_info.pickup_component_id)
			if(id_info.driver_id==system_info.pickup_driver_id)
	
	}
	return ft;
}

