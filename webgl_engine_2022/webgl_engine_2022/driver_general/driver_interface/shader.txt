struct vertex_to_fragment_struct
{
	@builtin(position)	vertex_position		:	vec4<f32>,

	@location(0)		vertex_id			:	vec4<f32>,
	@location(1)		vertex_texture		:	vec4<f32>
};
struct fragment_to_target_struct
{
	@builtin(frag_depth)	depth			:	f32,
	@location(0) 			fragment_color	:	vec4<f32>,
	@location(1) 			fragment_id		:	vec4<i32>,
};

struct interface_parameter
{
	texture_x0		:	f32,
	texture_y0		:	f32,
	texture_dx		:	f32,
	texture_dy		:	f32,
	
	depth			:	f32,
	
	high_light_x0	:	f32,
	high_light_y0	:	f32,
	high_light_x1	:	f32,
	high_light_y1	:	f32
};

@group(1) @binding(0) var <uniform>par			:	interface_parameter;
@group(1) @binding(1) var interface_texture		:	texture_2d<f32>;
@group(1) @binding(2) var interface_sampler		:	sampler;

@vertex
fn vertex_main(
		@location(0) my_coord		:	vec4<f32>,
		@location(1) my_normal		:	vec4<f32>,
		@location(2) my_matetal		:	vec4<f32>,
		@location(3) my_id			:	vec4<f32>,
		@location(4) my_texture		:	vec4<f32>
	)->vertex_to_fragment_struct
{
	var vf:vertex_to_fragment_struct;

	vf.vertex_position	=vec4<f32>(
		par.texture_x0+my_coord.x*par.texture_dx,
		par.texture_y0+my_coord.y*par.texture_dy,
		my_coord.z,my_coord.w);

	vf.vertex_id		=my_id;
	vf.vertex_texture	=my_texture;

	return vf;
}

@fragment
fn fragment_main(vf	:	vertex_to_fragment_struct) ->  fragment_to_target_struct
{
	var ft:fragment_to_target_struct;

	ft.fragment_color	=textureSample(interface_texture,interface_sampler,vf.vertex_texture.xy);
	ft.fragment_id		=vec4<i32>(
		id_info.component_system_id,			i32(vf.vertex_id.x),
		i32(vf.vertex_texture.x*1000.0*1000.0),	i32(vf.vertex_texture.y*1000.0*1000.0));

	ft.depth=par.depth;
	
	ft.fragment_color.w=1.0;
	
	if(	  (vf.vertex_texture.x>=par.high_light_x0)
		&&(vf.vertex_texture.x<=par.high_light_x1)
		&&(vf.vertex_texture.y>=par.high_light_y0)
		&&(vf.vertex_texture.y<=par.high_light_y1))
	{
		if(system_info.millisecond<500)
		{
			ft.fragment_color.w=0.0;
		}
	}
	return ft;
}